{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\nconst useBooks = (searchQuery, page = 1) => {\n  _s();\n  const [books, setBooks] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [hasMore, setHasMore] = useState(false);\n  const [currentPage, setCurrentPage] = useState(page);\n  useEffect(() => {\n    // Don't fetch if search query is empty\n    if (!searchQuery || searchQuery.trim() === '') {\n      setBooks([]);\n      setLoading(false);\n      setError(null);\n      setHasMore(false);\n      setCurrentPage(1);\n      return;\n    }\n    const fetchBooks = async () => {\n      setLoading(true);\n      setError(null);\n      try {\n        const response = await fetch(`https://openlibrary.org/search.json?q=${encodeURIComponent(searchQuery)}&page=${currentPage}`);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n\n        // Parse response.docs and map to our desired format with random price\n        const mappedBooks = data.docs.map(doc => ({\n          key: doc.key,\n          title: doc.title,\n          author_name: doc.author_name ? doc.author_name[0] : 'Unknown Author',\n          cover_i: doc.cover_i,\n          first_publish_year: doc.first_publish_year,\n          price: Math.floor(Math.random() * 50) + 10 // Random price between 10-60 TL\n        }));\n\n        // If it's page 1, replace books, otherwise append\n        if (currentPage === 1) {\n          setBooks(mappedBooks);\n        } else {\n          setBooks(prevBooks => [...prevBooks, ...mappedBooks]);\n        }\n\n        // Check if more results exist\n        setHasMore(data.docs.length > 0);\n      } catch (err) {\n        setError(err.message);\n        setBooks([]);\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchBooks();\n  }, [searchQuery, currentPage]);\n  const loadMore = useCallback(() => {\n    setCurrentPage(prevPage => prevPage + 1);\n  }, []);\n  return {\n    books,\n    loading,\n    error,\n    loadMore,\n    hasMore\n  };\n};\n_s(useBooks, \"GxlqUaMK/4sA+jsaEdciDw+obsY=\");\nexport default useBooks;","map":{"version":3,"names":["useState","useEffect","useCallback","useBooks","searchQuery","page","_s","books","setBooks","loading","setLoading","error","setError","hasMore","setHasMore","currentPage","setCurrentPage","trim","fetchBooks","response","fetch","encodeURIComponent","ok","Error","status","data","json","mappedBooks","docs","map","doc","key","title","author_name","cover_i","first_publish_year","price","Math","floor","random","prevBooks","length","err","message","loadMore","prevPage"],"sources":["C:/Users/payal/Desktop/Online Kitap Magazasi/src/hooks/useBooks.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\n\nconst useBooks = (searchQuery, page = 1) => {\n  const [books, setBooks] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [hasMore, setHasMore] = useState(false);\n  const [currentPage, setCurrentPage] = useState(page);\n\n  useEffect(() => {\n    // Don't fetch if search query is empty\n    if (!searchQuery || searchQuery.trim() === '') {\n      setBooks([]);\n      setLoading(false);\n      setError(null);\n      setHasMore(false);\n      setCurrentPage(1);\n      return;\n    }\n\n    const fetchBooks = async () => {\n      setLoading(true);\n      setError(null);\n      \n      try {\n        const response = await fetch(\n          `https://openlibrary.org/search.json?q=${encodeURIComponent(searchQuery)}&page=${currentPage}`\n        );\n        \n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        // Parse response.docs and map to our desired format with random price\n        const mappedBooks = data.docs.map(doc => ({\n          key: doc.key,\n          title: doc.title,\n          author_name: doc.author_name ? doc.author_name[0] : 'Unknown Author',\n          cover_i: doc.cover_i,\n          first_publish_year: doc.first_publish_year,\n          price: Math.floor(Math.random() * 50) + 10 // Random price between 10-60 TL\n        }));\n        \n        // If it's page 1, replace books, otherwise append\n        if (currentPage === 1) {\n          setBooks(mappedBooks);\n        } else {\n          setBooks(prevBooks => [...prevBooks, ...mappedBooks]);\n        }\n        \n        // Check if more results exist\n        setHasMore(data.docs.length > 0);\n      } catch (err) {\n        setError(err.message);\n        setBooks([]);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchBooks();\n  }, [searchQuery, currentPage]);\n\n  const loadMore = useCallback(() => {\n    setCurrentPage(prevPage => prevPage + 1);\n  }, []);\n\n  return { \n    books, \n    loading, \n    error, \n    loadMore, \n    hasMore \n  };\n};\n\nexport default useBooks; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}